package kr.co.abacus.abms.application.chat;

import java.util.List;
import java.util.Locale;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemoryRepository;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.MessageType;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;

import kr.co.abacus.abms.application.chat.outbound.ChatSessionRepository;

@Slf4j
@Service
public class ChatTitleService {

    private static final String DEFAULT_TITLE = "새로운 대화";
    private static final int TITLE_MAX_LENGTH = 50;
    private static final List<String> GREETING_KEYWORDS = List.of(
            "안녕", "hi", "hello", "반가", "좋은 아침", "좋은 저녁", "수고", "고마워", "감사");
    private static final String TITLE_PROMPT = """
            다음은 사용자의 대화 요청들입니다.
            이 맥락을 가장 잘 나타내는 한국어 대화 제목을 생성하세요.

            요구사항:
            - 5단어 이내
            - 30자 이내
            - 제목만 출력 (따옴표, 설명, 번호 금지)

            사용자 요청:
            %s
            """;

    private final ChatClient chatClient;
    private final ChatSessionRepository chatSessionRepository;
    private final ChatMemoryRepository chatMemoryRepository;

    public ChatTitleService(
            ChatClient.Builder chatClientBuilder,
            ChatSessionRepository chatSessionRepository,
            ChatMemoryRepository chatMemoryRepository) {
        this.chatClient = chatClientBuilder.build();
        this.chatSessionRepository = chatSessionRepository;
        this.chatMemoryRepository = chatMemoryRepository;
    }

    @Transactional
    public void applyInitialTitle(String sessionId, String userMessage) {
        String initialTitle = createInitialTitleWithAi(userMessage);
        chatSessionRepository.findBySessionIdAndDeletedFalse(sessionId)
                .ifPresent(session -> {
                    if (session.getTitle() == null
                            || session.getTitle().isBlank()
                            || DEFAULT_TITLE.equals(session.getTitle())) {
                        session.updateTitle(initialTitle);
                        chatSessionRepository.save(session);
                    }
                });
    }

    @Async
    @Transactional
    public void refineTitleAsync(String sessionId) {
        try {
            List<Message> memoryMessages = chatMemoryRepository.findByConversationId(sessionId);
            List<String> allUserMessages = memoryMessages.stream()
                    .filter(message -> message.getMessageType() == MessageType.USER)
                    .map(Message::getText)
                    .filter(text -> text != null && !text.isBlank())
                    .toList();

            if (allUserMessages.size() != 3) {
                return;
            }

            String firstMessageTitle = createInitialTitle(allUserMessages.get(0));
            String currentTitle = chatSessionRepository.findBySessionIdAndDeletedFalse(sessionId)
                    .map(session -> session.getTitle())
                    .orElse("");
            if (!isAutoGeneratedTitle(currentTitle, firstMessageTitle)) {
                return;
            }

            List<String> candidateMessages = allUserMessages.stream()
                    .map(String::trim)
                    .filter(message -> !isGreetingMessage(message))
                    .toList();
            List<String> contextMessages = candidateMessages.isEmpty() ? allUserMessages : candidateMessages;
            String messageContext = toMessageContext(contextMessages);

            String response = chatClient.prompt()
                    .user(String.format(TITLE_PROMPT, messageContext))
                    .call()
                    .content();

            if (response == null || response.isBlank()) {
                return;
            }

            String refinedTitle = normalizeTitle(response);
            chatSessionRepository.findBySessionIdAndDeletedFalse(sessionId).ifPresent(session -> {
                if (!refinedTitle.equals(session.getTitle())) {
                    session.updateTitle(refinedTitle);
                    chatSessionRepository.save(session);
                    log.info("Refined title for session {}: {}", sessionId, refinedTitle);
                }
            });
        } catch (Exception e) {
            log.warn("Failed to refine title for session {}: {}", sessionId, e.getMessage());
        }
    }

    private String toMessageContext(List<String> userMessages) {
        int size = userMessages.size();
        int fromIndex = Math.max(0, size - 3);
        List<String> recentMessages = userMessages.subList(fromIndex, size);
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < recentMessages.size(); i++) {
            builder.append(i + 1)
                    .append(". ")
                    .append(recentMessages.get(i).trim())
                    .append('\n');
        }
        return builder.toString().trim();
    }

    private boolean isAutoGeneratedTitle(String currentTitle, String firstMessageTitle) {
        if (currentTitle == null || currentTitle.isBlank()) {
            return true;
        }
        return DEFAULT_TITLE.equals(currentTitle) || firstMessageTitle.equals(currentTitle);
    }

    private String createInitialTitle(String userMessage) {
        String normalized = normalizeTitle(userMessage);
        if (normalized.isBlank()) {
            return DEFAULT_TITLE;
        }
        return normalized;
    }

    private String createInitialTitleWithAi(String userMessage) {
        String fallbackTitle = createInitialTitle(userMessage);
        try {
            String messageContext = toMessageContext(List.of(userMessage));
            String response = chatClient.prompt()
                    .user(String.format(TITLE_PROMPT, messageContext))
                    .call()
                    .content();
            if (response == null || response.isBlank()) {
                return fallbackTitle;
            }
            String refinedTitle = normalizeTitle(response);
            return refinedTitle.isBlank() ? fallbackTitle : refinedTitle;
        } catch (Exception e) {
            log.warn("Failed to create initial AI title: {}", e.getMessage());
            return fallbackTitle;
        }
    }

    private boolean isGreetingMessage(String message) {
        String normalized = message.toLowerCase(Locale.ROOT).trim();
        if (normalized.length() <= 6) {
            return true;
        }
        return GREETING_KEYWORDS.stream().anyMatch(normalized::contains);
    }

    private String normalizeTitle(String value) {
        String normalized = value
                .replace('\n', ' ')
                .replace('\r', ' ')
                .replaceAll("^['\"`\\[\\(\\s]+", "")
                .replaceAll("['\"`\\]\\)\\s]+$", "")
                .replaceAll("\\s+", " ")
                .trim();

        if (normalized.length() > TITLE_MAX_LENGTH) {
            normalized = normalized.substring(0, TITLE_MAX_LENGTH).trim();
        }
        return normalized;
    }

}
