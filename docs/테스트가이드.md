# 백엔드 테스트 가이드 (TDD 기반)

이 문서는 ABMS 백엔드(`src/main/java`) 개발을 위한 **테스트 전략과 작성 규칙**을 정리합니다.
프로젝트의 Hexagonal Architecture(`adapter -> application -> domain`)를 그대로 따라, 테스트도 레이어별로 목적을 분리합니다.

> 핵심 목표
> - 빠른 피드백: 도메인 규칙은 Spring 없이 단위 테스트로 빠르게
> - 회귀 방지: 유스케이스/정책은 통합 테스트로 확실하게
> - 계약 고정: API는 HTTP 레벨의 계약 테스트로 깨짐을 조기 감지
> - 개발 방식: 기본은 **TDD(테스트 우선 개발)**

---

## 1. 테스트 분류(레이어 관점)

| 분류 | 위치(권장) | 무엇을 검증? | 실행 속도 | 대표 베이스/도구 |
|---|---|---|---:|---|
| Domain 단위 테스트 | `src/test/java/**/domain/**` | 상태 전이, 불변식, 도메인 예외 | 매우 빠름 | JUnit5 + AssertJ |
| Application Manager 테스트 | `src/test/java/**/application/**/inbound/*ManagerTest.java` | 유스케이스 + DB 반영 + 트랜잭션 | 중간 | `IntegrationTestBase` (`@SpringBootTest`, `@Transactional`) |
| Application Finder 테스트 | `src/test/java/**/application/**/inbound/*FinderTest.java` | 조회 로직 + 페이징/정렬/필터링 | 중간 | `IntegrationTestBase` |
| Adapter(API) 테스트 | `src/test/java/**/adapter/api/**` | HTTP 계약(상태코드/validation/페이징/정렬/파일) | 느림 | `ApiIntegrationTestBase` + `RestTestClient` / `MockMvc` |
| Repository 테스트 | `src/test/java/**/application/**/outbound/*RepositoryTest.java` | DB 쿼리/조회 로직 검증 | 중간 | `IntegrationTestBase` |
| Architecture 규칙 테스트 | `src/test/java/**` | 레이어 의존성 위반 방지 | 빠름 | ArchUnit (`HexagonalArchitectureTest`) |

> 원칙: **가장 아래 레이어일수록 테스트를 더 많이** 작성합니다.

> **CQRS 패턴 테스트 분리**:
> - `*ManagerTest`: 상태 변경(생성/수정/삭제/상태 전이) 유스케이스 테스트
> - `*FinderTest`: 조회(단건/목록/페이징/정렬/필터링) 유스케이스 테스트

---

## 2. 프로젝트에 이미 적용된 테스트 인프라

### 2-1) 공통 설정

- `src/test/resources/junit-platform.properties`
  - `spring.test.constructor.autowire.mode=all`

### 2-2) 통합 테스트 베이스

- `kr.co.abacus.abms.support.IntegrationTestBase`
  - `@SpringBootTest`
  - `@Transactional`
  - `@ActiveProfiles("test")`
  - `flush() / clear() / flushAndClear()` 제공

> `flushAndClear()`는 JPA 1차 캐시(영속성 컨텍스트) 착시를 제거하는 핵심 도구입니다.

### 2-3) API 테스트 베이스

- `kr.co.abacus.abms.support.ApiIntegrationTestBase extends IntegrationTestBase`
  - `RestTestClient` 바인딩
  - `MockMvc`도 함께 세팅
  - `ObjectMapper` 주입

> **RestTestClient vs MockMvc 사용 기준**:
> - **RestTestClient**: 일반적인 JSON API 요청/응답 테스트 (GET/POST/PUT/PATCH/DELETE)
> - **MockMvc**: 파일 업로드/다운로드, 멀티파트 요청 테스트
>   - Excel 업로드, 파일 다운로드 등 Multipart 요청은 MockMvc 사용

### 2-4) 아키텍처(ArchUnit) 테스트

- `kr.co.abacus.abms.HexagonalArchitectureTest`
  - `domain/application/adapter` 레이어 규칙을 테스트로 고정

---

## 3. TDD 사이클을 테스트 레이어에 매핑하기

TDD는 **Red → Green → Refactor** 사이클입니다. 이 프로젝트에서는 다음 규칙으로 적용합니다.

### 3-1) 어디서부터 Red를 만들까?

요구사항 유형에 따라 “첫 테스트”의 레이어를 다르게 시작합니다.

1) **도메인 규칙/상태 전이/검증 로직 추가**
- 시작점: `domain` 단위 테스트
- 이유: 빠르고, 실패 원인이 명확하고, 프레임워크 영향을 제거할 수 있음

2) **유스케이스(policy) 추가** (예: “퇴사 처리는 ACTIVE일 때만 가능”, “중복 이메일이면 생성 실패”)
- 시작점: `application` 통합 테스트
- 이유: 도메인만으로는 정책이 완성되지 않고, 리포지토리/트랜잭션 포함해 검증해야 함

3) **API 계약 변경/추가** (예: validation 규칙 추가, 응답 shape 변경, 정렬 규칙 고정)
- 시작점: `adapter.api` API 통합 테스트
- 이유: 깨지는 지점이 “HTTP 계약”이므로 테스트도 HTTP 레벨에서 먼저 실패해야 안전함

### 3-2) Green(최소 구현) 규칙

- 테스트를 통과시키기 위한 **최소한의 구현**만 넣습니다.
- 도메인/서비스에서 과한 공통화나 추상화는 Refactor 단계로 미룹니다.

### 3-3) Refactor(정리) 규칙

- 중복 제거, 네이밍 정리, 테스트 픽스처 공통화는 이 단계에서만 합니다.
- 단, 테스트 가독성을 해치는 공통화(거대한 Fixture Factory)는 지양합니다.

---

## 4. Domain 테스트 가이드 (Spring 없이)

### 4-1) 무엇을 테스트하나?

- 상태 전이 (예: `ACTIVE -> ON_LEAVE`, `ACTIVE -> RESIGNED`)
- 불변식 검증 (예: 퇴사일은 입사일 이후)
- 도메인 예외 타입/메시지
- 엔티티의 행위 메서드(예: `resign`, `takeLeave`, `promote`, `softDelete`)

### 4-2) 무엇을 테스트하지 않나?

- JPA 매핑(@Entity) 자체의 동작
- Repository 쿼리
- Controller 바인딩/직렬화

### 4-3) 리포 내 예시

- `src/test/java/kr/co/abacus/abms/domain/employee/EmployeeTest.java`
  - `resignBeforeJoinDate()` (날짜 불변식)
  - `takeLeaveFail()` (상태 전이 제약)
  - `softDelete()` (삭제 정책)

### 4-4) 권장 템플릿

- Given: 엔티티를 `create()`로 만들고 필요한 상태로 세팅
- When: 행위 호출
- Then: 상태/필드/예외 검증

> 팁: 도메인 테스트는 “실패 원인”이 바로 보이도록 **assert를 과감히 상세하게** 씁니다.

---

## 5. Application 통합 테스트 가이드 (유스케이스 + DB)

### 5-1) 무엇을 테스트하나?

- 유스케이스(매니저/서비스)가 정책을 올바르게 실행하는지
- 저장/조회/변경이 실제 DB에 반영되는지
- 트랜잭션 안에서 일관되게 동작하는지

### 5-2) 기본 베이스 클래스 사용

Application 통합 테스트는 기본적으로 `IntegrationTestBase`를 상속합니다.

- 테스트 중 DB 반영 검증을 할 때는 다음 패턴을 권장합니다.
  - 저장/변경
  - `flushAndClear()`
  - 재조회해서 검증

### 5-3) 리포 내 예시

- `src/test/java/kr/co/abacus/abms/application/employee/inbound/EmployeeManagerTest.java`
  - `duplicateEmail()` : 중복 이메일 정책
  - `resignFail_beforeJoinDate()` : 유스케이스에서 도메인 규칙 위반 시 실패
  - `delete()` : soft delete 정책(DB 반영)

### 5-4) 테스트 데이터/픽스처 팁

- 현재 테스트들은 각 테스트에서 필요한 엔티티를 직접 생성하고 저장합니다.
- 공통 세팅은 `@BeforeEach`에서 최소화(예: 부서 트리 생성)하는 정도가 적절합니다.

---

## 6. Adapter(API) 테스트 가이드 (HTTP 계약)

### 6-1) 무엇을 테스트하나?

- 상태코드(200/201/204/400/404...)
- Request validation(Body/QueryParam)
- 응답 JSON의 shape(필드명/타입/nullable)
- 페이징/정렬 계약(`page`, `size`, `sort`)
- 파일 업/다운로드(엑셀)

### 6-2) 어떤 도구를 쓸까? (현재 리포 표준)

- 기본: `RestTestClient`
  - JSON 요청/응답, 상태 코드 검증이 간결
- 필요 시: `MockMvc`
  - 멀티파트, 파일 업로드/다운로드 검증이 더 편할 때 사용

둘 다 `ApiIntegrationTestBase`에서 준비되어 있으니, 테스트 내용에 맞게 선택하면 됩니다.

### 6-3) 리포 내 예시

- `src/test/java/kr/co/abacus/abms/adapter/api/employee/EmployeeApiTest.java`
  - `create_invalidEmail()` → validation으로 400
  - `search_sortByGradeLevel()` → 정렬 계약 고정
  - `getEmployeeGrades()/Positions()/Types()` → enum 목록 계약

### 6-4) API 테스트 체크리스트(권장)

- [ ] 상태 코드가 맞는가?
- [ ] validation이 기대대로 동작하는가?
- [ ] 응답 필드가 누락/변형되지 않았는가?
- [ ] 정렬/페이징 계약이 깨지지 않았는가?
- [ ] (변경 API라면) `flushAndClear()` 이후 DB에서 결과를 재확인했는가?

---

## 7. 예시: TDD로 기능 하나 추가하기(가이드 시나리오)

여기서는 예시로 **"퇴사 처리 시 퇴사일이 오늘 이후면 안 된다"** 같은 정책을 추가한다고 가정합니다.

### 7-1) Red (테스트부터 추가)

1) 가장 적절한 레이어 선택
- 정책이 유스케이스/도메인 어디에 위치하는지 먼저 결정합니다.
- 날짜 검증이 도메인의 불변식이라면 Domain 테스트부터,
- 정책이 유스케이스(입력 제약)라면 Application 통합 테스트부터 시작합니다.

2) 실패 테스트 작성
- `assertThatThrownBy(...).isInstanceOf(...).hasMessage(...)` 형태로 실패 원인을 명확히 적습니다.

### 7-2) Green (최소 구현)

- 도메인 메서드(또는 유스케이스)에서 최소한의 조건만 추가해 통과시킵니다.

### 7-3) Refactor

- 중복 검증 로직 정리
- 에러 메시지/예외 타입 정렬
- 테스트 픽스처를 읽기 좋게 다듬기

---

## 8. 품질 게이트(실행 범위 권장)

- 로컬(자주): Domain + Application 위주로 빠르게
- PR/머지 전: 백엔드 전체 테스트 + ArchUnit 포함

> 참고: ArchUnit 테스트는 개발 중 “레이어 깨짐”을 조기에 알려주는 안전장치입니다. 실패하면 구조를 먼저 되돌리는 게 보통 더 싸게 먹힙니다.
