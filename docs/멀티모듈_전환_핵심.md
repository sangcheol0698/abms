# ABMS 멀티모듈 전환 핵심 정리

## 1. 왜 바꿨나
- 단일 모듈에서 섞여 있던 책임(domain/application/adapter/boot)을 분리해 변경 영향 범위를 줄이고 빌드/리뷰 단위를 명확히 하기 위함.
- API 런타임과 Batch 런타임을 분리해 실행 설정 충돌(특히 배치 자동 실행)을 방지하기 위함.

## 2. 현재 모듈 구성

| 모듈 | 책임 |
|---|---|
| `abms-domain` | 엔티티/VO/도메인 규칙 |
| `abms-application` | 유스케이스, inbound/outbound port, application DTO |
| `abms-adapter-web` | REST API, HTTP 경계 DTO, Security HTTP 설정 |
| `abms-adapter-persistence` | JPA/Querydsl 기반 DB 어댑터 구현 |
| `abms-adapter-integration` | 메일/캐시/AI/보안 서비스 등 외부 통합 |
| `abms-adapter-batch` | Batch Job/Step 정의 |
| `abms-api-boot` | API 앱 조립/실행 |
| `abms-batch-boot` | Batch 앱 조립/실행 |
| `frontend` | Vue 앱 (Gradle 멀티모듈 범위 밖) |

## 3. 의존성 규칙 (중요)
- 기본 방향: `adapter -> application -> domain`
- `domain`은 `application/adapter`를 참조하면 안 됨.
- `application`은 `adapter`를 참조하면 안 됨.
- `application` outbound는 Spring Data 상속 없이 순수 포트 인터페이스만 둠.
- DB 구현(Spring Data/JPA/Querydsl)은 `abms-adapter-persistence`에서만 구현.

> 위 규칙은 ArchUnit 테스트로 강제된다.

## 4. 런타임 분리
- API 실행: `./gradlew bootRun` (alias -> `:abms-api-boot:bootRun`)
- Batch 실행: `./gradlew bootRunBatch` (alias -> `:abms-batch-boot:bootRun`)
- 특정 배치 잡 실행 예시:
  - `./gradlew :abms-batch-boot:bootRun --args='--spring.batch.job.name=revenueMonthlySummaryJob'`

### 기본 동작
- API boot: `spring.batch.job.enabled=false`
- Batch boot: `spring.batch.job.enabled=true`

## 5. 테스트 위치/실행 기준
- 도메인 단위 테스트: `abms-domain/src/test/java`
- API/통합/아키텍처 테스트: `abms-api-boot/src/test/java`
- 배치 통합 테스트: `abms-batch-boot/src/test/java`

핵심 명령:
- 전체 검증: `./gradlew clean build`
- 빠른 회귀: `./gradlew test`

## 6. 팀 개발 시 체크리스트
- 새 유스케이스 추가 시: `application`에 포트/서비스를 먼저 정의하고, 구현은 adapter로 분리했는지 확인.
- API DTO(`adapter-web`)가 `application`으로 넘어가지 않는지 확인.
- repository 인터페이스를 `application`에 추가할 때 Spring Data 타입을 상속하지 않았는지 확인.
- API 기능 변경 PR은 `abms-api-boot` 테스트, 배치 변경 PR은 `abms-batch-boot` 테스트까지 포함해 검증.

## 7. 참고
- 모듈 등록: `settings.gradle.kts`
- 공통 빌드 규칙/alias task: `build.gradle.kts`
- 상세 실행/개발 가이드: `README.md`
